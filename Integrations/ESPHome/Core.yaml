substitutions:
  name: apollo-pump-1
  friendly_name: Apollo Pump-1
  version: "25.8.6.1"
  device_description: ${name} made by Apollo Automation - version ${version}.

esp32:
  board: esp32-c6-devkitm-1
  variant: esp32c6
  flash_size: 8MB
  framework:
    type: esp-idf

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}
  on_boot:
    - priority: 600
      then:
        - lambda: |-
            id(pump_start_time) = 0;
            id(safety_alert_active) = false;
        - script.execute: pump_safety_check

    - priority: -100
      then:
        - lambda: |-
            if (id(sntp_time).now().timestamp == 0) {
              id(last_run_timestamp) = 0;  // discard stale value
            }

    - priority: -100
      then:
        - delay: 1000ms
        - script.execute: statusCheck
    - priority: -10
      then:
        - if:
            condition:
              - lambda: "return id(runTest);"
            then:
              - lambda: "id(testScript).execute();"

# Enable logging
logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Apollo-Pump-1 Fallback Hotspot"
    password: "D9xJDUpZF6EP"

api:
  services:
    - service: play_buzzer
      variables:
        song_str: string
      then:
        - rtttl.play:
            rtttl: !lambda "return song_str;"
    - service: run_pump_for_seconds
      variables:
        seconds: int
      then:
        - switch.turn_on: pump_control
        - delay: !lambda "return seconds * 1000;"
        - switch.turn_off: pump_control
    - service: run_pump_until_full
      then:
        - script.execute: pumpUntilFull

time:
  - platform: sntp #<<<<<<<<<<<<<<<< Added for Interval Functionality
    id: sntp_time
    timezone: "America/New_York"

globals:
  - id: last_run_timestamp #<<<<<<<<<<<<<<<< Added for Interval Functionality
    type: uint32_t
    restore_value: yes
    initial_value: "0"
  - id: pump_cycle_count #<<<<<<<<<<<<<<<< Added for Interval Functionality
    type: int
    restore_value: yes
    initial_value: "0"
  - id: alert_active #<<<<<<<<<<<<<<<< Added for Interval Functionality
    type: bool
    restore_value: no
    initial_value: "false"

  - id: pump_start_time
    restore_value: no
    type: uint32_t
    initial_value: "0"
  - id: safety_alert_active
    restore_value: no
    type: bool
    initial_value: "false"
  - id: runTest
    restore_value: yes
    type: bool
    initial_value: "true"
  - id: testCycleCount
    type: int

captive_portal:

web_server:
  port: 80

# Buzzer

output:
  - platform: ledc
    pin: GPIO5
    id: buzzer
rtttl:
  output: buzzer

button:
  - platform: restart
    icon: mdi:power-cycle
    name: "ESP Reboot"

  - platform: factory_reset
    disabled_by_default: True
    name: "Factory Reset ESP"
    id: factory_reset_all

  - platform: template
    name: "Run Pump"
    id: run_pump_button
    icon: mdi:pump
    on_press:
      then:
        - lambda: |- #<<<<<<<<<<<<<<<< Added for Interval Functionality
            id(pump_cycle_count) += 1;
            ESP_LOGD("pump", "Cycle count: %d", id(pump_cycle_count));
        - switch.turn_on: pump_control
        - delay: !lambda "return (int)id(pump_run_seconds).state * 1000;"
        - switch.turn_off: pump_control

  - platform: template
    name: "Run Pump Until Output Wet"
    id: run_pump_until_out_wet
    icon: mdi:pump
    disabled_by_default: true
    on_press:
      then:
        script.execute: pumpUntilFull

  - platform: template
    name: "Play Buzzer â†¯" # Added to confirm Buzzer works
    id: play_buzzer_button
    icon: mdi:surround-sound
    on_press:
      then:
        - rtttl.play: !lambda return "scale_up:d=32,o=5,b=100:c,c#,d#,e,f#,g#,a#,b";

  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Confirm Refill (Resets Pump Cycles) â†¯"
    icon: mdi:check-circle
    on_press:
      then:
        - lambda: |-
            id(pump_cycle_count) = 0;
            id(pump_cycle_sensor).publish_state(0);
            id(alert_active) = false;

switch:
  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Enable Pump Interval Runs â†¯"
    id: enable_pump_interval
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_off:
      - lambda: |-
          id(alert_active) = false;

  - platform: factory_reset
    id: factory_reset_switch
    internal: true
    icon: mdi:shield-off
  - platform: template
    name: "Stop Pump When Output Wet"
    id: stop_pump_when_full
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:water-sync
    entity_category: config
  - platform: template
    name: "Stop Pump When Input Dry"
    id: stop_pump_when_dry
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:water-sync
    entity_category: config
  - platform: template
    name: "Pump Safety Override"
    id: pump_safety_override
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    icon: mdi:shield-alert-outline
    disabled_by_default: true

  - platform: gpio
    pin: GPIO7
    name: "Pump Control"
    id: pump_control
    entity_category: config
    disabled_by_default: true
    on_turn_on:
      then:
        - if:
            condition:
              or:
                - binary_sensor.is_on: fluid_input_sensor
                - switch.is_off: stop_pump_when_dry
            then:
              - logger.log: "Pump turning on - conditions met"
              - lambda: |-
                  id(pump_start_time) = millis();
                  id(safety_alert_active) = false;
              - script.execute: pump_safety_check
            else:
              - logger.log: "Pump blocked - water conditions not met"
              - switch.turn_off: pump_control
    on_turn_off:
      then:
        - lambda: |-
            id(pump_start_time) = 0;
            id(safety_alert_active) = false;
        - logger.log: "Pump turned off"

binary_sensor:
  - platform: status
    name: Online
    id: ink_ha_connected
  - platform: gpio
    id: reset_button
    pin:
      number: GPIO9
      inverted: true
      mode:
        input: true
        pullup: true
    on_multi_click:
      - timing:
          - ON for at least 10s
        then:
          - button.press: factory_reset_all
      - timing:
          - ON for at least 3s
          - OFF for at least 0.2s
        then:
          - script.execute: statusCheck
          - delay: 3s
          - globals.set:
              id: testCycleCount
              value: "0"
          - globals.set:
              id: runTest
              value: "true"
          - script.execute: testScript
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - script.execute: run_pump_timed

  - platform: gpio
    name: Fluid Input
    id: fluid_input_sensor
    icon: mdi:water
    device_class: moisture
    pin:
      number: GPIO4
      mode:
        input: true
        pullup: true
      inverted: true

  - platform: gpio
    name: Fluid Output
    id: fulid_output_sensor
    icon: mdi:water
    device_class: moisture
    pin:
      number: GPIO14
      mode:
        input: true
        pullup: true
      inverted: true

  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Pump Alert Active â†¯"
    lambda: |-
      return id(alert_active);
    icon: mdi:alert

number:
  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Pump Interval (in Hours) â†¯"
    id: pump_interval_hours
    icon: mdi:timer
    min_value: 1
    max_value: 720
    step: 1
    mode: box
    initial_value: 12
    unit_of_measurement: "hours"
    restore_value: true
    optimistic: true
  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Tank Size (oz) â†¯"
    id: tank_size_oz
    icon: mdi:cup
    min_value: 1
    max_value: 128
    step: 1
    mode: box
    initial_value: 64
    unit_of_measurement: "oz"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Pump Run Seconds (1s = 15mL)"
    id: pump_run_seconds
    icon: mdi:timer
    optimistic: true
    min_value: 1
    max_value: 120
    step: 1
    initial_value: 10
    unit_of_measurement: "s"
    restore_value: true
    mode: box
  - platform: template
    name: "Max Safe Run Time"
    id: max_safe_run_time
    entity_category: config
    icon: mdi:timer-alert
    optimistic: true
    min_value: 5
    max_value: 600
    step: 10
    initial_value: 60
    unit_of_measurement: "s"
    restore_value: true
    mode: box

sensor:
  - platform: internal_temperature
    name: "ESP Temperature"
    id: sys_esp_temperature
    disabled_by_default: true

  - platform: uptime
    name: Uptime
    id: sys_uptime
    update_interval: 60s

  - platform: wifi_signal
    name: RSSI
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Pump Cycle Count â†¯"
    id: pump_cycle_sensor
    lambda: |-
      return id(pump_cycle_count);
    update_interval: 30s
    accuracy_decimals: 0
    icon: mdi:counter
  - platform: template #<<<<<<<<<<<<<<<< Added for Interval Functionality
    name: "Pump Cycle Threshold (Computed) â†¯"
    id: pump_cycle_threshold
    lambda: |-
      // Flow: 900 mL/min â†’ 15 mL/s â†’ ~0.507 oz/s
      const float flow_oz_per_sec = 900.0f / 60.0f / 29.5735f;
      const float run_s = id(pump_run_seconds).state;
      const float tank_oz = id(tank_size_oz).state;

      if (run_s <= 0.0f || tank_oz <= 0.0f) return 0.0f;

      const float dose_oz_per_cycle = flow_oz_per_sec * run_s;
      return ceilf(tank_oz / dose_oz_per_cycle);
    update_interval: 10s
    unit_of_measurement: "Cycles"
    accuracy_decimals: 0
    icon: mdi:counter

light:
  - platform: esp32_rmt_led_strip
    id: rgb_light
    name: "RGB Light"
    pin: GPIO3
    default_transition_length: 0s
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
    # Add explicit power supply limit to prevent current spikes
    max_refresh_rate: 20ms
    effects:
      - pulse:
          name: "Slow Pulse"
          transition_length: 1000ms
          update_interval: 1000ms
          min_brightness: 0%
          max_brightness: 100%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%

script:
  - id: pumpUntilFull
    then:
      - switch.turn_on: stop_pump_when_full
      - delay: 100ms # Small delay to ensure switch state is updated
      - switch.turn_on: pump_control

  - id: statusCheck
    then:
      - if:
          condition:
            - lambda: "return id(ink_ha_connected).state;"
          then:
            - logger.log: "Apollo Automation: Connected To HA"
            - light.turn_on:
                id: rgb_light
                brightness: 100%
                red: 0%
                green: 0%
                blue: 100%
          else:
            - if:
                condition:
                  - wifi.connected
                then:
                  - logger.log: "Apollo Automation: Connected To Wifi"
                  - light.turn_on:
                      id: rgb_light
                      brightness: 100%
                      red: 0%
                      green: 100%
                      blue: 0%
                else:
                  - logger.log: "Apollo Automation: Not Connected To Wifi"
                  - light.turn_on:
                      id: rgb_light
                      brightness: 100%
                      red: 100%
                      green: 100%
                      blue: 0%
      - delay: 5s
      - light.turn_off: rgb_light
  - id: run_pump_timed
    then:
      - switch.turn_on: pump_control
      - delay: !lambda "return (int)id(pump_run_seconds).state * 1000;"
      - switch.turn_off: pump_control
  - id: pump_safety_check
    mode: restart
    then:
      - while:
          condition:
            - switch.is_on: pump_control
          then:
            - if:
                condition:
                  - and:
                      - switch.is_on: stop_pump_when_full
                      - binary_sensor.is_on: fulid_output_sensor
                then:
                  - logger.log: "Pump stopping - tank full"
                  - switch.turn_off: pump_control
            - if:
                condition:
                  - lambda: |-
                      if (id(pump_start_time) == 0) return false;
                      uint32_t runtime = (millis() - id(pump_start_time)) / 1000;
                      return runtime > id(max_safe_run_time).state && !id(pump_safety_override).state;
                then:
                  - logger.log: "Pump stopping - safety"
                  - switch.turn_off: pump_control
            - if:
                condition:
                  - and:
                      - switch.is_on: stop_pump_when_dry
                      - binary_sensor.is_on: fluid_input_sensor
                then:
                  - logger.log: "Pump stopping - input dry"
                  - switch.turn_off: pump_control
            - delay: 1s
  - id: testScript
    then:
      if:
        condition:
          - lambda: "return id(runTest) == true;"
        then:
          - lambda: "id(runTest) = false;"
          - lambda: "id(testCycleCount) = 0;"
          - lambda: "id(runTest) = false;"
          - light.turn_on:
              id: rgb_light
              red: 0%
              green: 100%
              blue: 0%
          - delay: 5s
          - light.turn_on:
              id: rgb_light
              red: 0%
              green: 0%
              blue: 0%
          - light.turn_off:
              id: rgb_light

  - id: run_buzzer_alert #<<<<<<<<<<<<<<<< Added for Interval Functionality
    mode: restart
    then:
      - output.ledc.set_frequency:
          id: buzzer
          frequency: 1500Hz
      - output.set_level:
          id: buzzer
          level: 50%
      - delay: 500ms
      - output.set_level:
          id: buzzer
          level: 0%

#======================================================================
# Interval schedulers for Intervals, alerts, and LED state.
#======================================================================
interval:
  # Scheduler: run at set interval if enabled and fluid is present or cycle threshold not exceeded.
  - interval: 60s
    then:
      - lambda: |-
          if (!id(enable_pump_interval).state) {
            ESP_LOGD("pump", "Interval skipped: pump interval disabled");
            return;
          }

          // ðŸ” Primary check: ultrasonic fluid sensor
          if (id(stop_pump_when_dry).state && !id(fluid_input_sensor).state) {
            id(alert_active) = true;
            ESP_LOGD("pump", "Interval blocked: fluid sensor reports dry and stop_pump_when_dry is enabled");
            return;
          }

          // ðŸ§® Fallback check: cycle threshold
          if (id(pump_cycle_count) >= (int) id(pump_cycle_threshold).state) {
            id(alert_active) = true;
            ESP_LOGD("pump", "Interval blocked: cycle threshold reached, Tank Might be Empty!");
            return;
          }

          // ðŸ•’ Time-based interval logic
          uint32_t now = id(sntp_time).now().timestamp;
          if (now == 0) {
            now = millis() / 1000;
            ESP_LOGD("pump", "Using millis() as fallback timestamp");
          }

          uint32_t interval_s = (uint32_t)(id(pump_interval_hours).state * 3600);
          if ((now - id(last_run_timestamp)) >= interval_s) {
            id(last_run_timestamp) = now;
            id(run_pump_button).press();
            id(pump_cycle_count) += 1;
            id(pump_cycle_sensor).publish_state(id(pump_cycle_count));
            ESP_LOGD("pump", "Cycle count: %d", id(pump_cycle_count));
          }

  # Alert buzzer reminder while enabled and alert is active.
  - interval: 60s
    then:
      - lambda: |-
          if (id(alert_active) && id(enable_pump_interval).state) {
            id(run_buzzer_alert).execute();                       
          }

  # LED feedback: fluid sensor is primary; warn near threshold; red pulse on alert.
  - interval: 60s
    then:
      - lambda: |-
          auto count = id(pump_cycle_count);                      
          auto threshold = (int) id(pump_cycle_threshold).state;

          if (!id(enable_pump_interval).state) {
            id(rgb_light).turn_off();                             
            return;
          }

          // ðŸ” Primary check: ultrasonic fluid sensor
          if (!id(fluid_input_sensor).state) {
            id(rgb_light).turn_on();  // Red alert will be handled below
            return;
          }

          // ðŸ§® Fallback: warn if near threshold
          if (id(alert_active)) {
            id(rgb_light).turn_on();                              
          } else if (count >= threshold - 6) {
            id(rgb_light).turn_on();                              
          } else {
            id(rgb_light).turn_off();                             
          }

      - if:
          condition:
            lambda: |-
              // Red pulse if alert is active or fluid is missing
              return id(alert_active) || !id(fluid_input_sensor).state;
          then:
            - light.turn_on:
                id: rgb_light
                brightness: 100%
                red: 100%
                green: 0%
                blue: 0%
                effect: "Slow Pulse"

      - if:
          condition:
            lambda: |-
              auto count = id(pump_cycle_count);                  
              auto threshold = (int) id(pump_cycle_threshold).state;
              return count >= threshold - 6 && id(fluid_input_sensor).state && !id(alert_active);
          then:
            - light.turn_on:
                id: rgb_light
                brightness: 100%
                red: 100%
                green: 100%
                blue: 0%
                effect: "Slow Pulse"
